**NetworkStructures research experiment software**

The software used to conduct the experiments is based on a web application that implements the Model-View-Controller pattern using Microsoft .NET Framework (version 4.7.2). The data was stored in a SQL Server 2017 database, and the database connection was developed using Entity Framework (version 6.2), an object-relational mapper developed by Microsoft. The application is written in C# 7.3 and JavaScript languages. The client was designed functionally and visually using JQuery, Bootstrap 3 and D3.js. Finally, the website was hosted on a shared server of the provider "Centron" (http://www.centron.de) and delivered to the connected players via ASP.NET.

The provision of a responsive, turn-based multiplayer application is only possible with limitations via a conventional client-server system, which forms the basis of common web applications. In particular, full request/response cycles often lead to longer system response times, which should be avoided as much as possible in experimental studies. On the other hand, the NetworkStructures experiment requires a permanent bidirectional exchange of data between server and client, since data has to be stored permanently in a database and information from previous rounds has to be provided to all participants in each round. For this reason, the core of the application was implemented server-based, within a SignalR hub (version 2.4.1) managed by an ASP.NET MVC client-server application. The SignalR hub controls round synchronization by means of a session-wide timer through the exchange of appropriate signals (more precisely: Remote Procedure Calls, RPC) on a bidirectional connection between the server and each connected client browser in which the application runs.

In this context, the SignalR library is of particular importance, since in principle it is not possible to ensure that all recruited participants in a multiplayer experiment are connected to the server via a browser that supports WebSockets transport, currently the most powerful transport model. SignalR enables the establishment of a bidirectional connection between .NET code on a server and JavaScript code in a web application in any popular browser by negotiating which transport mechanism can be used when establishing the connection. If the client browser does not support WebSockets, SignalR can fall back on legacy transports to synchronize the multiplayer system, even if participants are connected via outdated browser versions. SignalR also makes it possible to monitor connection lifetime and respond to faults. Because of this, in the event of a connection failure, it was usually possible - if the client was still connected to the Internet at all - to re-establish the connection between the application and the server in the following round with up-to-date data and minimal data loss. The resulting application proved to be quite stable and responsive.

*Settings*

The application allows to realize a large number of variations of the described paradigm through a variety of settings - e.g. group size, number of rounds, images for the used items, number of items, payoff rates and noise values, extent and duration of visibility of patterns and results of all players or any subgroups, various options in graphical representation of the game progress, specification of the maximum time to submit a solution. Moreover, an experiment can be localized with a suitable editor view, i.e. run on the same web page in any language.

*Program flow*

As soon as a potential player connects to the website at a given time via a sent link with a special ID, the application first checks if there is a current session. If there is no current session with a free seat for another player, a new session is created and the person is added as the first player, otherwise - if the number of teammates is less than the scheduled number - the person is assigned to the session and directed to a page called the "waiting room", where a counting down clock indicates the waiting time until the latest possible start of the experiment. If all scheduled participants have registered by this time, the experiment will begin immediately after the last required participant has registered. If the number of scheduled participants is not reached, but a minimum number to be specified in the settings is connected, all unoccupied seats are filled by "virtual" players, for whom the application simulates user behavior according to a predefined plan, and the experiment is also started. If the number of connected "real" players is less than the required minimum number at the time the waiting period expires, the application is terminated and the players waiting at that time are prompted to reconnect at another time assigned to them by the experiment administrators.

A study session consists of a number of runs specified in the settings. The display of the experiment screen begins with an RPC call to a JavaScript function in the waiting room display page, which calls a controller function that passes the experiment view from the server to the client browser. From this point on, the flow of the experiment is controlled by a session-wide timer on the server. Queries are also sent to the database at regular intervals to verify that all players have sent data. If all clients complete a round quickly, this could drastically reduce the wait time until the next round begins.

If player data is missing after the current round is completed, it is automatically determined from previous rounds for the next round and entered into the database before the next round is started. To ensure synchronization, the data required for display on a client is also transferred with the start call. The processing of all actions in the browser is handled by JavaScript functions.
Since it cannot be verified that the use of a server-controlled timer can guarantee that the editing options are actually available to the user for a certain period of time, the start of the display, the end of the editing phase and the end of the display of the experiment screen are controlled by a JavaScript timer. At the end of the round, this timer also reads all collected data from specially created hidden controls and sends it back to the server via SignalR, which processes it and writes it to the database.

*Application monitoring and data output*.

In a special administration area of the application, an investigator can both fully trace the history of past sessions and monitor the progress of a session in real time. To this end, the administration view establishes a bi-directional connection to the server via SignalR, allowing it to view all data sent and received by clients and the server, and to check the status of a session. Finally, a special hierarchical view of the processed data from the database allows viewing and downloading detailed information about each action performed by a specific user in a round, as well as the corresponding aggregated data of a single subject or the entire study.

*Source code availability*

Source code for the application will be made available at http://github.com/sciencec/networkstructures/ as of the publication date of the journal article.
