**NetworkStructures experimental software**

The software used to conduct the experimental study is based on the deployment of a web page implementing the Model-View-Controller pattern using .Net Framework version 4.7.2 and a database connection developed with Entity Framework (version 6.2) to the SQL Server 2017 database management system. The web application was developed in C# 7.3 and JavaScript languages, functionally and visually designed using JQuery, Bootstrap 3 and D3.js, hosted using a shared server from the provider Centron (www.centron.de) and delivered to the connected players via ASP.NET.

Since the provision of a (approximately) real-time, turn-based multiplayer application via a client-server system, which forms the basis of common ASP.NET applications, is practically impossible, the core of the experimental application was implemented server-based within a SignalR hub (version 2.4.1). This controls the lap timing by means of a timer and synchronizes the running of a session through a bidirectional connection to each connected client browser by sending appropriate signals to the browsers (more precisely: through Remote Procedure Calls, RPC).

In this context, the SignalR library is of particular importance, because in principle it cannot be ensured that all recruited participants of a multi-user experiment connected via the Web are connected to the server via a browser that supports transport via WebSockets, currently the most powerful transport model. SignalR allows a bi-directional connection to be established between .Net code on a server and JavaScript code of a web application in any popular browser by checking which transport mechanism can be used when the connection is established. If the client browser does not support the HTML5 standard or does not support it fully, SignalR can fall back on older transports and thus still synchronize the functionality of an interactive system with multiple players even if the participants are connected via older browsers.

*Settings*

The application can realize a large number of variations of the described paradigm through a variety of settings - group size, number of rounds, images for the items used, number of items, payoff and noise specifications, extent and duration of visibility of patterns and scores of all players or any subgroups, various options in the graphical display of the score history, specification of the maximum time to submit a solution. Moreover, an experiment can be localized by an appropriate editor, i.e. conducted in any language.

*Program flow*

As soon as a potential player connects to the website at a certain time via a sent link containing a special ID, the application first checks whether a current session exists. If there is no current session with a free slot for another player, a new session is created and the person is added as the first player, otherwise - if the number of teammates is less than the planned number - the person is assigned to the session and directed to a page to be called "waiting room", where a counting down clock shows the waiting time until the latest possible start of the experiment. If all scheduled players have registered by that time, the experiment will start immediately after the last required player connects. If the number of planned participants is not reached, but a minimum number to be specified in the settings is reached, all unoccupied seats are occupied by "virtual" players for whom the application simulates user behavior according to a specified plan, and the experiment is also started. If the number of logged-in players at the time of the expiration of the waiting period is less than the minimum number of real players, the application is terminated and the players waiting at that time are asked to reconnect at another time assigned to them by the experiment administrators.

The experimental session consists of a number of runs specified in the settings. The display of the experimental screen starts with an RPC call to a JavaScript function in the waiting room display page, which calls a controller function that delivers the experimental view from the server to the client browser. From this point on, the flow of the experiment is controlled by a timer on the server. Furthermore, a check is made at short intervals to see if data has been sent from all players.

If the data of other players is missing, it is automatically determined for the next round from previous rounds and added to the database. The next round is then started. To ensure synchronization, the data required for display on a client is also transferred with this call. JavaScript functions handle the processing of all actions in the browser. Since there is no control whether the use of the server-driven timer can ensure that the editing options are actually available to the user for a predetermined period of time, the start of the display, the end of the editing phase, and the end of the display of the experimental screen are handled by a JavaScript timer. At the end of the round, this timer also reads all the accumulated data from specially created hidden controls and sends them back to the server via SignalR, which processes and writes the data to the database.

*Program flow control and data output*

An investigator can both fully track the progress of past sessions and monitor the progress of a session in real time in a special administration area of the application. For this purpose, the administration view establishes a bidirectional connection to server via SignalR and is thus able to inspect all data sent and received by clients and server and check the status of a session. Finally, a special hierarchical view of the processed data from the database allows viewing and downloading detailed information about each individual action of a specific user in a round as well as appropriate aggregated data of the whole study.

*Source code availability*

The source code for the application will be made available at http://github.com/sciencec/networkstructures/ as of the publication date of the journal article.
